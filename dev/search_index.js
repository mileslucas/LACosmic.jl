var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = LACosmic","category":"page"},{"location":"#LACosmic.jl","page":"Home","title":"LACosmic.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: GitHub) (Image: Code)) (Image: Build Status) (Image: Coverage) (Image: License)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Documentation for LACosmic.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [LACosmic]","category":"page"},{"location":"#LACosmic.subsample","page":"Home","title":"LACosmic.subsample","text":"LACosmic.subsample(array, block_size=2)\n\nSubsample array by the given factor without copying or allocating. This effectively treats each pixel as block_size x block_size pixels. The value of each pixel is not normalized or averaged. This is a view into the parent array, and if the data was changed this view would change subsequently.\n\nExamples\n\njulia> arr = [1 2; 3 4]\n\njulia> sub = LACosmic.subsample(arr)\n4×4 LACosmic.SubsampledArray{Int64, 2, Matrix{Int64}}:\n 1  1  2  2\n 1  1  2  2\n 3  3  4  4\n 3  3  4  4\n\njulia> all(sub[1:2, 1:2] .=== arr[1, 1])\ntrue\n\njulia> sub[3, 3] = 5;\n\njulia> sub\n4×4 LACosmic.SubsampledArray{Int64, 2, Matrix{Int64}}:\n 1  1  2  2\n 1  1  2  2\n 3  3  5  5\n 3  3  5  5\n\n\n\n\n\n","category":"function"}]
}
